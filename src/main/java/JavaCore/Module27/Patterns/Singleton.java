package JavaCore.Module27.Patterns;

public class Singleton {}
    /*Одиночка — это порождающий паттерн проектирования, который гарантирует,
    что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа*/

//Первый способ. Самый простой способ реализовать Синглтон
/*public*//* class DataBase {
    private static int count = 0;
    // Приватный конструктор не позволяет создавать новые экземпляры за пределами текущего класса.
    //При каждом вызове конструктора переменная count будет увеличиваться на 1
    private DataBase() {
        count++;
    }
    // Сразу создаем объект, который будет единственным экземпляром класса
    private static DataBase dataBase = new DataBase();
    // getInstance() является глобальной точкой доступа к объекту Singleton. Вызывать одиночку мы сможем так: DataBase.getInstance().
    public static DataBase getInstance(){
        return dataBase;
    }
    //  Метод getCount() выведет информацию о количестве созданных экземпляров
    public void getCount() {
        System.out.println(count);
    }
}

class DBMain{
    public static void main(String[] args) {
        DataBase dataBase = DataBase.getInstance();
        dataBase.getCount();
        DataBase dataBase2 = DataBase.getInstance();
        dataBase2.getCount();
    }
}*/
/*Данный способ позволяет получать единственный экземпляр класса как в однопоточных системах, так и в многопоточных.
Это возможно благодаря тому, что экземпляр создается при инициализации приложения и при вызове метода getInstance()
этот экземпляр возвращается. При этом количество вызовов статического метода getInstance() не приведет к созданию
новых объектов. У данного способа есть серьезный недостаток. Объект при запуске программы и находится в памяти
до завершения работы независимо от того, воспользуемся мы синглтоном или нет. То есть объект-одиночка создается всегда*/


/*Второй способ. Ленивая инициализация*/
/*При втором способе синглтон создается после первого вызова метода getInstance().
Для этого примера нужно немного изменить класс DataBase. В дальнейшем для экономии
времени удалим из кода переменную count, метод getCount() и класс DBMain.*/
/*public*//*
 class DataBase {
    //  Приватный конструктор класса
    private DataBase() {
    }
    // Теперь синглтон будем создавать после первого вызова метода getInstance()
    private static DataBase dataBase;
    // Проверяем, если объект dataBase не существует, только тогда мы его создадим, т.е. производим ленивую инициализацию синглтона.
    public static DataBase getInstance(){
        if (dataBase == null)
            return new DataBase();
    }
}*/
/*Теперь мы получили ленивую инициализацию синглтона, которая будет работать в однопоточной среде.
А вот с многопоточной средой возникнут проблемы. При одновременном вызове метода getInstance()
несколькими потоками синглтон может проинициализироваться несколько раз, и вместо единственного экземпляра
мы можем получить несколько разных объектов.*/

/*Способ третий. Синхронизировать метод getInstance()*/
/*public*//* class DataBase {
    //  Приватный конструктор класса
    private DataBase() {
    }
    // Теперь синглтон будем создавать после первого вызова метода getInstance
    private static DataBase dataBase;
    // Проверяем, если объект dataBase не существует, только тогда мы его создадим, т.е. производим ленивую инициализацию синглтона.
    public static synchronized DataBase getInstance(){
        if (dataBase == null)
            return new DataBase();
    }
}*/
/*Теперь наряду с ленивой инициализацией мы заставили Синглтон работать в многопоточной среде.
Теперь поток, который первый занимает метод getInstance(), блокирует доступ к нему остальным потокам
и спокойно инициализирует синглтон. Остальный потоки получат готовый объект-одиночку.
Но и в этом способе не все гладко. Из-за синхронизации метода getInstance() произойдет снижение
производительности. По сути синхронизация getInstance() нам нужна только до момента инициализации Синглтона*/

/*Способ четвертый. Синхронизируем инициализацию Синглтона*/
/*public*//* class DataBase {
    //  Приватный конструктор класса
    private DataBase() {
    }
    // Без volatile работать не будет
    private static volatile DataBase dataBase;
    //  Синхронизируем не весь метод getInstance(), а только момент инициализации объекта.
    public static DataBase getInstance(){
        if (dataBase == null){
            // Проверяем, если объект dataBase не существует, тогда синхронизируем наш класс одиночку (DataBase).
            synchronized (DataBase.class){
                //  снова проверяем, если объект все еще не существует, тогда его создаем
                if (dataBase == null){
                    dataBase = new DataBase();
                }
            }
        }
        return dataBase;
    }
}*/
/*Допустим, несколько потоков одновременно вызывают метод getInstance(). Метод проверяет, что объект Одиночка
ещё не создан. Эти несколько потоков проходят на следующий этап, где их ждет синхронизация класса DataBase (Одиночки).
Поток, который быстрее всех доходит до этой точки, блокирует работу остальных потоков и еще раз проверяет наличие
или отсутствие объекта одиночки. Если объект до сих пор не существует, то вызывается конструктор класса и создается
объект. Поток, который был заблокирован первым потоком, проверяет наличие объекта Одиночки, который у нас уже появился,
соответственно новый объект не создают, а возвращают уже созданный. Потоки, которые вызывают метод getInstance()
после инициализации Синглтона, не проходят первую проверку на null и возвращают готовый синглтон. Благодаря такому
решению мы увеличили производительность*/

/*Способ пятый. Использование внутренних классов*/
/*public*//* class DataBase {
    private int count = 0;
    //  Приватный конструктор класса
    private DataBase() {
        count++;
        System.out.println(count);
    }
    //  Создадим внутренний класс DataBaseHolder с приватным статическим полем, которое содержит в себе новый объект одиночку.
    private static class DataBaseHolder{
        private final static DataBase databaseHolder = new DataBase();
    }

    public static DataBase getInstance(){
        return DataBaseHolder.databaseHolder;
    }
}

class DBMain{
    public static void main(String[] args) {
        DataBase.getInstance();
        DataBase.getInstance();
    }
}*/
/*Особенность данного способа заключается в том, что Синглтон в getInstance() нам генерирует внутренний класс
DataBaseHolder. А особенностью внутренних классов Java является то, что они инициализируются после первого к
ним обращения. Данный вариант не подходит для нестатических полей класса*/